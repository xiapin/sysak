---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/2/14 3:14 PM
---

local unistd = require("posix.unistd")
local socket = require("posix.sys.socket")
local system = require("common.system")
require("common.class")

local CLocalBeaver = class("poBeaver")

function CLocalBeaver:_init_(port, ip, backlog)
    port = port or 8398

    self._bfd = self:_install_fd(port, ip, backlog)
    self._efd = self:_installFFI()

    self._cos = {}
    self._last = os.time()
    self._tmos = {}

    self._once = true
end

function CLocalBeaver:_del_()
    if self._efd then
        self._cffi.deinit(self._efd)
    end
    if self._bfd then
        unistd.close(self._bfd)
    end
end

local function posixError(msg, err, errno)
    local s = msg .. string.format(": %s, errno: %d", err, errno)
    error(s)
end

function CLocalBeaver:_installTmo(fd)
    self._tmos[fd] = os.time()
end

function CLocalBeaver:_checkTmo()
    local now = os.time()
    if now - self._last >= 10 then
        -- ! coroutine will del self._tmos cell in loop, so create a mirror table for safety
        local tmos = system:dictCopy(self._tmos)
        for fd, t in pairs(tmos) do
            if now - t >= 10 then
                local e = self._ffi.new("native_event_t")
                e.ev_close = 1
                e.fd = fd
                local co = self._cos[fd]
                print("close " .. fd)
                coroutine.resume(co, e)
            end
        end
        self._last = now
    end
end

function CLocalBeaver:_installFFI()
    local ffi = require("native.beavercffi")

    self._ffi = ffi.ffi
    self._cffi = ffi.cffi

    local efd = self._cffi.init(self._bfd)
    assert(efd > 0)
    return efd
end

function CLocalBeaver:_install_fd(port, ip, backlog)
    ip = ip or "0.0.0.0"
    backlog = backlog or 100

    local fd, res, err, errno
    fd, err, errno = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
    if fd then  -- for socket
        res, err, errno = socket.bind(fd, {family=socket.AF_INET, addr=ip, port=port})
        if res then  -- for bind
            res, err, errno = socket.listen(fd, backlog)
            if res then -- for listen
                return fd
            else
                posixError("socket listen failed", err, errno)
            end
        else   -- for bind failed
            unistd.close(fd)
            posixError("socket bind failed", err, errno)
        end
    else  -- socket failed
        posixError("create socket failed", err, errno)
    end
end

function CLocalBeaver:read(fd, maxLen)
    maxLen = maxLen or 1 * 1024 * 1024  -- signal conversation accept 1M stream max
    local function readFd()
        local e = coroutine.yield()
        if e.ev_close > 0 then
            return nil
        elseif e.ev_in > 0 then
            local s, err, errno
            s, err, errno = socket.recv(fd, maxLen)
            if s then
                maxLen = maxLen - #s
                return s
            else
                posixError("socket recv error", err, errno)
            end
        else
            print(system:dump(e))
        end
        return nil
    end
    return readFd
end

function CLocalBeaver:_readStream(fd)
    local sockRead = self:read(fd)
    local res = ""
    while true do
        local s = sockRead()
        if s then
            if #s > 0 then
                res = res .. s
                if string.find(res, "\r\n") then
                    return res
                end
            else
                return nil
            end
        else
            return nil
        end
    end
end

function CLocalBeaver:_proc(fd)
    while true do
        local s = self:_readStream(fd)
        if s then
            socket.send(fd, string.format("echo: %s", s))
        else
            self:co_exit(fd)
            break
        end
    end
end

function CLocalBeaver:co_add(fd)
    local res = self._cffi.add_fd(self._efd, fd)
    assert(res >= 0)

    local co = coroutine.create(function(o, fd)  self._proc(o, fd) end)
    self._cos[fd] = co
    local res, msg = coroutine.resume(co, self, fd)
    assert(res, msg)
end

function CLocalBeaver:co_exit(fd)
    local res = self._cffi.del_fd(self._efd, fd)
    assert(res >= 0)

    self._cos[fd] = nil
    self._tmos[fd] = nil
end

function CLocalBeaver:accept(fd, e)
    if e.ev_close > 0 then
        error("should close bind fd.")
    else
        local nfd, err, errno = socket.accept(fd)
        if nfd then
            self:co_add(nfd)
            self:_installTmo(nfd)
        else
            posixError("accept new socket failed", err, errno)
        end
    end
end

function CLocalBeaver:_poll(bfd, nes)
    for i = 0, nes.num - 1 do
        local e = nes.evs[i];
        local fd = e.fd
        if fd == bfd then
            self:accept(fd, e)
        else
            local co = self._cos[fd]
            assert(co, string.format("fd: %d not setup.", fd))
            self:_installTmo(fd)
            local res, msg = coroutine.resume(co, e)
            assert(res, msg)
        end
    end
    self:_checkTmo()
end

function CLocalBeaver:poll()
    assert(self._once, "poll loop only run once time.")
    self._once = false

    local bfd = self._bfd
    local efd = self._efd
    while true do
        local nes = self._ffi.new("native_events_t")
        local res = self._cffi.poll_fds(efd, 10, nes)

        if res < 0 then
            break
        end

        self:_poll(bfd, nes)
    end

    for fd in pairs(self._cos) do
        local res = self._cffi.del_fd(self._efd, fd)
        assert(res >= 0)
    end
end

return CLocalBeaver