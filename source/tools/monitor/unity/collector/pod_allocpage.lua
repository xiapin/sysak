---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liuxinwnei.
--- DateTime: 2023/02/08 17:00 PM
---

require("common.class")
local fcntl = require("posix.fcntl")
local unistd = require("posix.unistd")
local dirent = require("posix.dirent")
local stdlib = require("posix.stdlib")
local stat = require("posix.sys.stat")
local CkvProc = require("collector.kvProc")
local CvProc = require("collector.vproc")
local pystring = require("common.pystring")
local dockerinfo = require("common.dockerinfo")
local json = require("cjson")
local CPodAlloc = class("podalloc", CkvProc)
local ChttpCli = require("httplib.httpCli")

function CPodAlloc:_init_(proto, pffi, mnt, pFile)
    CkvProc._init_(self, proto, pffi, mnt, pFile , "pod_alloc")
    self._ffi = require("collector.native.plugincffi")
    self.root_fs = mnt
    self.proc_fs = mnt .. "/proc/"
    self.name_space = {}
    self.pod_mem = {}
    self.inode_link = {}
    self.link_pid = {}
    self.cgroup_pod = {}
    self.allpods = {}
    self.blacklist = {["arms-prom"] = 1, ["kube-system"] = 1, ["kube-public"] = 1, ["kube-node-lease"] = 1}
    -- self.blacklist= {}
    self.total = 0
    self.count = 0
    self.cgroup_count = 0
end

function CPodAlloc:file_exists(file)
    local f=stat.lstat(file)
    if f ~= nil then
        return true
    else
        return false
    end
end

function CPodAlloc:switch_ns(file)
    if file == nil then file = self.proc_fs ..  "1/ns/net" end
    if not self:file_exists(file) then return end

    local f = fcntl.open(file,fcntl.O_RDONLY)
    if f == nil then return false end
    local res = self._ffi.C.setns(f,0)
    if res == -1 then return false end
    unistd.close(f)
    return true
end

function CPodAlloc:get_container_info(did)
    local restable = {}
    local podname = did
    local podns = did
    local cname = did
    
    res = dockerinfo:get_inspect(did, self.root_fs)
    res = pystring:strip(res)
    if #res == 0 then return podname,podns end
    local restable = json.decode(res)
    if not restable then return podname end
    if #restable > 0 then
        restable = restable[1]
    end
    if restable['Config'] then
        local config = restable['Config']
        if config['Labels'] then
            local label = config['Labels']
            if label['io.kubernetes.pod.name'] then
                podname = label['io.kubernetes.pod.name']
            end
            if label['io.kubernetes.container.name'] then
                cname = label['io.kubernetes.container.name']
            end
            if label['io.kubernetes.pod.namespace'] then
                podns = label['io.kubernetes.pod.namespace']
            end
        end
        if podname == did and restable['Name'] then
            cname = restable['Name']
            podname = restable['Name']
        end
    elseif restable['status'] then
        podname = restable['status']['labels']['io.kubernetes.pod.name']
        cname = restable['status']['labels']['io.kubernetes.container.name']
        podns = restable['status']['labels']['io.kubernetes.pod.namespace']
    end
    if pystring:startswith(podname,"/") then podname=string.sub(podname,2,-1) end
    return podname,podns
end

function CPodAlloc:get_pidalloc()
    local dockerids = {}
    for inode,nsfile in pairs(self.name_space) do
        local ns_res = self:switch_ns(nsfile)
        if not ns_res then goto continue end 
        -- local env = posix.getenv()
        -- env["PROC_ROOT"] = self.proc_fs
        stdlib.setenv("PROC_ROOT",self.proc_fs)
        local pfile = io.popen("ss -an| grep -E 'tcp|udp|raw' | awk '$3 > 0'","r")
        io.input(pfile)
        for line in io.lines() do
            repeat
            local proto,recv,srcip,srcport,dstip,dstport = string.match(line,"(%S*)%s*%S*%s*(%d*)%s+%d*%s*(%S*):(%d*)%s*(%S*):(%d*)")
            if not proto or not recv then break end
            if proto ~="tcp" and proto ~="udp" and proto ~="raw" then break end
            local index = srcip..srcport..dstip..dstport
            if not self.link_pid[index] then break end
            recv = tonumber(recv)
            local pid = self.link_pid[index]

            local dockerid = ""
            if not dockerids[pid] then
                dockerid = dockerinfo:get_dockerid(pid, self.root_fs)
                if dockerid == "unknow" then break end
                dockerids[pid] = dockerid
            else
                dockerid = dockerids[pid]
            end
            local podname = dockerid
            local podns = dockerid
            if not self.cgroup_pod[dockerid] then
                podname,podns = self:get_container_info(dockerid)
                self.cgroup_pod[dockerid] = {["podname"]=podname, ["podns"]=podns}
                self.cgroup_count = self.cgroup_count + 1
                if recv < 1024 and podname == dockerid then break end

            else
                podname = self.cgroup_pod[dockerid]["podname"]
                podns = self.cgroup_pod[dockerid]["podns"]
            end
            if not self.pod_mem[podname] then
                self.pod_mem[podname] = {}
                self.pod_mem[podname]["allocpage"] = 0
                self.pod_mem[podname]["podns"] = podns
                self.pod_mem[podname]["podname"] = podname
            end
            self.pod_mem[podname]["allocpage"] = self.pod_mem[podname]["allocpage"] + recv
            self.total = self.total + recv
        until true
        end
        pfile:close()
        self:switch_ns()
        stdlib.setenv("PROC_ROOT","")
        ::continue::
    end
end

function CPodAlloc:scan_namespace()
    local files = {"/var/run/docker/netns/","/var/run/netns/"}
    for _,nsfile in pairs(files) do
        if CPodAlloc:file_exists(self.root_fs ..nsfile) then
        for file in dirent.files(self.root_fs .. nsfile) do
            if not pystring:startswith(file,".") then
                local fs = stat.lstat(self.root_fs .. nsfile .. file)
                local inode = fs.st_ino
                if not self.name_space[inode] then self.name_space[inode] = pystring:strip(self.root_fs .. nsfile .. file) end
        end
        end
    end
end
end

function CPodAlloc:get_fdlink()
    for pid in dirent.files(self.proc_fs) do
        if not pystring:startswith(pid,".") then
            if self:file_exists(self.proc_fs .. pid .. "/fd") then
            for fd in dirent.files(self.proc_fs .. pid .. "/fd") do
                local res = stat.stat(self.proc_fs .. pid .. "/fd/" .. fd)
                if res and stat.S_ISSOCK(res.st_mode) then
                   if self.inode_link[tostring(res.st_ino)] then   self.link_pid[self.inode_link[tostring(res.st_ino)]] = pid end
                end
            end
            end
        end
    end
end

function CPodAlloc:get_link()
    local files = {"/net/tcp", "/net/udp", "/net/raw"}
    for _,file in pairs(files) do
        local lines = io.lines(self.proc_fs .. file)  
        lines()
        for line in lines do
            local srcip, srcport, dstip, dstport, inode =string.match(line,"%s*%d+:%s*([0-9A-F]+):([0-9A-F]+)%s+([0-9A-F]+):([0-9A-F]+)%s+[0-9A-f]+%s+[0-9A-F]+:[0-9A-F]+%s+[0-9A-F]+:[0-9A-F]+%s+[0-9A-F]+%s+%d+%s+%d+%s+(%d+)")
            if inode and inode ~= 0 then
                srcip = tonumber(srcip:sub(7,8),16) .. "." .. tonumber(srcip:sub(5,6),16) .. "." .. tonumber(srcip:sub(3,4),16) .. "." .. tonumber(srcip:sub(1,2),16)
                srcport = tonumber(srcport,16)
                dstip = tonumber(dstip:sub(7,8),16) .. "." .. tonumber(dstip:sub(5,6),16) .. "." .. tonumber(dstip:sub(3,4),16) .. "." .. tonumber(dstip:sub(1,2),16)
                dstport = tonumber(dstport,16)
                local index = srcip..srcport..dstip..dstport
                if not self.inode_link[inode] then self.inode_link[inode] = index end
            end
        end
    end
end

function CPodAlloc:get_allpods()
    local url = "http://127.0.0.1:10255/pods"
    local cli = ChttpCli.new()
    local content = cli:get(url)
    local obj = cli:jdecode(content.body)
    for _,v in pairs(obj['items']) do
        if not self.blacklist[v['metadata']['namespace']] then self.allpods[v['metadata']['name']] = v['metadata']['namespace'] end
    end
end

function CPodAlloc:proc(elapsed, lines)
    CvProc.proc(self)
    self.count = self.count + 1
    if (self.count-1) % 4 ~= 0 then
        for k,v in pairs(self.allpods) do
            local cell = nil
            if self.pod_mem[k] then 
                cell = {{name="pod_allocpage", value=self.pod_mem[k]['allocpage']/1024}}
            else
                cell = {{name="pod_allocpage", value=0}}
            end
            local label = {{name="podname",index=k,}, {name="podns",index = v,},}
            self:appendLine(self:_packProto("pod_alloc", label, cell))
        end
        local cell = {{name="pod_allocpage_total", value=self.total/1024}}
        self:appendLine(self:_packProto("pod_alloc", nil, cell))
        self:push(lines)
        return
    end
    self.name_space = {}
    self.pod_mem = {}
    self.inode_link = {}
    self.link_pid = {}
    self.allpods = {}
    if self.cgroup_count > 1000 then self.cgroup_pod = {} end
    self.total = 0

    self:get_link()
    self:get_fdlink()
    self:get_allpods()
    -- for k,v in pairs(self.link_pid) do print(k,v) end
    self:scan_namespace()
    self:get_pidalloc()

    for k,v in pairs(self.allpods) do
        local cell = nil
        if self.pod_mem[k] then 
            cell = {{name="pod_allocpage", value=self.pod_mem[k]['allocpage']/1024}}
        else
            cell = {{name="pod_allocpage", value=0}}
        end
        local label = {{name="podname",index=k,}, {name="podns",index = v,},}
        self:appendLine(self:_packProto("pod_alloc", label, cell))
    end
    local cell = {{name="pod_allocpage_total", value=self.total/1024}}
    self:appendLine(self:_packProto("pod_alloc", nil, cell))
    self:push(lines)
end
return CPodAlloc
