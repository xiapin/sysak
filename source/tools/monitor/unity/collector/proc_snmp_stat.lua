---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/1/19 11:19 PM
---

require("common.class")
local CvProc = require("collector.vproc")
local system = require("common.system")
local pystring = require("common.pystring")

local CprocSnmpStat = class("proc_snmp_stat", CvProc)

function CprocSnmpStat:_init_(proto, pffi, mnt, pFile)
    CvProc._init_(self, proto, pffi, mnt, pFile or nil)
    self._cellsMon = {'retrans', 'abort', 'paws', 'err', 'fail', 'drop', 'overflow'}
    self._rec = nil
end

function CprocSnmpStat:createTable(titles, values, now)
    local head = string.gsub(self._ffi.string(titles.s[0]), ":", "")
    assert(self._ffi.string(titles.s[0]), self._ffi.string(values.s))
    for i=1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        local low = string.lower(cell)
        for j, mon in ipairs(self._cellsMon) do
            if string.find(low, mon) then
                local title = string.format("%s_%s", head, cell)
                local value = values.value[i - 1]
                now[title] = value
            end
        end
    end
end

function CprocSnmpStat:_proc(inf, now)
    local i = 1
    local titles = self._ffi.new("var_string_t")
    local values = self._ffi.new("var_kvs_t")
    for line in io.lines(inf) do
        i = i + 1
        if (i % 2) == 0 then
            assert(self._cffi.var_input_string(self._ffi.string(line), titles) == 0)
        else
            assert(self._cffi.var_input_kvs(self._ffi.string(line), values) == 0)
            self:createTable(titles, values, now)
        end
    end
end

function CprocSnmpStat:createLabels()
    local labels = {}
    for _, label in ipairs(self._cellsMon) do
        labels[label] = 0
    end
    return labels
end

function CprocSnmpStat:pack(labels, logs)
    local vs = {}
    local c = 0
    for k, v in pairs(labels) do
        local value = {
            name = k,
            value = tonumber(v)
        }
        c = c + 1
        vs[c] = value
    end
    self:appendLine(self:_packProto("pkt_status", nil, vs))
    if #logs > 0 then
        local log = pystring:join("; ", logs)
        local outLog = {
            {
                name = "log",
                log = log,
            }
        }
        self:appendLine(self:_packProto("pkt_log", nil, nil, outLog))
    end
end

function CprocSnmpStat:check(now)
    local labels = self:createLabels()
    local logs = {}
    if self._rec then
        local c = 0
        for k, v in pairs(now) do
            if self._rec[k] and self._rec[k] < v then   --
                local delta = v - self._rec[k]
                for lk, lv in pairs(labels) do
                    local title = string.lower(k)
                    if string.find(title, lk) then
                        labels[lk] = lv + delta
                    end
                end
                c = c + 1
                logs[c] = string.format("%s: %d", k, tonumber(delta))
            end
        end
    end
    self:pack(labels, logs)
    self._rec = now
end

function CprocSnmpStat:proc(elapsed, lines)
    CvProc.proc(self)
    local now = {}
    self:_proc(self.pFile .. "proc/net/snmp", now)
    self:_proc(self.pFile .. "proc/net/netstat", now)
    self:check(now)
    self:push(lines)
end

return CprocSnmpStat
