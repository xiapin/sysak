---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/1/19 11:19 PM
---

require("common.class")
local CvProc = require("collector.vproc")
local system = require("common.system")
local pystring = require("common.pystring")

local CprocSnmpStat = class("proc_snmp_stat", CvProc)

function CprocSnmpStat:_init_(proto, pffi, mnt, pFile)
    CvProc._init_(self, proto, pffi, mnt, pFile or nil)
    self._cellsMon = {'retrans', 'abort', 'paws', 'err', 'fail', 'drop', 'overflow'}
    self._rec = nil
end

local ipHeads = {"InReceives", "OutRequests"}
function CprocSnmpStat:ipCount(titles, values)
    local vs = {}
    for i = 1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        if cell == "Forwarding" then
            table.insert(vs, {name = cell, value = tonumber(values.value[i - 1])})
        elseif system:valueIsIn(ipHeads, cell) then
            local name = "v_ip" .. cell
            local v = tonumber(values.value[i - 1])
            if self[name] then
                table.insert(vs, {name = cell, value = v - self[name]})
            end
            self[name] = v
        end
    end
    self:appendLine(self:_packProto("net_ip_count", nil, vs))
end

local icmpHeads = {"InMsgs", "InErrors", "OutMsgs", "OutErrors"}
function CprocSnmpStat:icmpCount(titles, values)
    local vs = {}
    for i = 1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        if system:valueIsIn(icmpHeads, cell) then
            local name = "v_icmp" .. cell
            local v = tonumber(values.value[i - 1])
            if self[name] then
                table.insert(vs, {name = cell, value = v - self[name]})
            end
            self[name] = v
        end
    end
    if #vs > 0 then
        self:appendLine(self:_packProto("net_icmp_count", nil, vs))
    end
end

local udpHeads = {"InDatagrams", "InErrors", "OutDatagrams",
                    "RcvbufErrors", "SndbufErrors", "NoPorts"}
function CprocSnmpStat:udpCount(titles, values)
    local vs = {}
    for i = 1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        if system:valueIsIn(udpHeads, cell) then
            local name = "v_udp" .. cell
            local v = tonumber(values.value[i - 1])
            if self[name] then
                table.insert(vs, {name = cell, value = v - self[name]})
            end
            self[name] = v
        end
    end
    if #vs > 0 then
        self:appendLine(self:_packProto("net_udp_count", nil, vs))
    end
end

local tcpHeads = {"InSegs", "OutSegs", "RetransSegs", "InErrs"}
function CprocSnmpStat:tcpCount(titles, values)
    local vs = {}
    for i = 1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        if cell == "CurrEstab" then
            table.insert(vs, {name = cell, value = tonumber(values.value[i - 1])})
        elseif system:valueIsIn(tcpHeads, cell) then
            local name = "v_tcp" .. cell
            local v = tonumber(values.value[i - 1])
            if self[name] then
                table.insert(vs, {name = cell, value = v - self[name]})
            end
            self[name] = v
        end
    end
    if #vs > 0 then
        self:appendLine(self:_packProto("net_tcp_count", nil, vs))
    end
end

local tcpExtHeads = {"TCPSynRetrans", "ListenDrops", "ListenOverflows",
                     "SyncookiesSent", "SyncookiesRecv", "SyncookiesFailed",
                     "ActiveOpens", "PassiveOpens"}
function CprocSnmpStat:tcpExtCount(titles, values)
    local vs = {}
    for i = 1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        if system:valueIsIn(tcpExtHeads, cell) then
            local name = "v_tcpExt" .. cell
            local v = tonumber(values.value[i - 1])
            if self[name] then
                table.insert(vs, {name = cell, value = v - self[name]})
            end
            self[name] = v
        end
    end
    if #vs > 0 then
        self:appendLine(self:_packProto("net_tcp_ext_count", nil, vs))
    end
end

function CprocSnmpStat:createTable(titles, values, now)
    local head = string.gsub(self._ffi.string(titles.s[0]), ":", "")
    assert(self._ffi.string(titles.s[0]), self._ffi.string(values.s))

    if head == "Tcp" then
        self:tcpCount(titles, values)
    elseif head == "Udp" then
        self:udpCount(titles, values)
    elseif head == "Ip" then
        self:ipCount(titles, values)
    elseif head == "Icmp" then
        self:icmpCount(titles, values)
    elseif head == "TcpExt" then
        self:tcpExtCount(titles, values)
    end

    for i = 1, titles.no do
        local cell = self._ffi.string(titles.s[i])
        local low = string.lower(cell)
        for j, mon in ipairs(self._cellsMon) do
            if string.find(low, mon) then
                local title = string.format("%s_%s", head, cell)
                local value = values.value[i - 1]
                now[title] = value
            end
        end
    end
end

function CprocSnmpStat:_proc(inf, now)
    local i = 1
    local titles = self._ffi.new("var_string_t")
    local values = self._ffi.new("var_kvs_t")
    for line in io.lines(inf) do
        i = i + 1
        if (i % 2) == 0 then
            assert(self._cffi.var_input_string(self._ffi.string(line), titles) == 0)
        else
            assert(self._cffi.var_input_kvs(self._ffi.string(line), values) == 0)
            self:createTable(titles, values, now)
        end
    end
end

function CprocSnmpStat:createLabels()
    local labels = {}
    for _, label in ipairs(self._cellsMon) do
        labels[label] = 0
    end
    return labels
end

function CprocSnmpStat:pack(labels, logs)
    local vs = {}
    local c = 0
    for k, v in pairs(labels) do
        local value = {
            name = k,
            value = tonumber(v)
        }
        c = c + 1
        vs[c] = value
    end
    self:appendLine(self:_packProto("pkt_status", nil, vs))
    if #logs > 0 then
        local log = pystring:join("; ", logs)
        local outLog = {
            {
                name = "log",
                log = log,
            }
        }
        self:appendLine(self:_packProto("pkt_log", nil, nil, outLog))
    end
end

function CprocSnmpStat:check(now)
    local labels = self:createLabels()
    local logs = {}
    if self._rec then
        local c = 0
        for k, v in pairs(now) do
            if self._rec[k] and self._rec[k] < v then   --
                local delta = v - self._rec[k]
                for lk, lv in pairs(labels) do
                    local title = string.lower(k)
                    if string.find(title, lk) then
                        labels[lk] = lv + delta
                    end
                end
                c = c + 1
                logs[c] = string.format("%s: %d", k, tonumber(delta))
            end
        end
    end
    self:pack(labels, logs)
    self._rec = now
end

function CprocSnmpStat:proc(elapsed, lines)
    CvProc.proc(self)
    local now = {}
    self:_proc(self.pFile .. "proc/net/snmp", now)
    self:_proc(self.pFile .. "proc/net/netstat", now)
    self:check(now)
    self:push(lines)
end

return CprocSnmpStat
