---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/4/12 16:26
---

require("common.class")
local system = require("common.system")
local CdiskFifo = require("collector.io.diskFifo")
local CexecptCheck = class("CexecptCheck")

-- [[  v format
--    iowait: 1
--    disk_a: {
--        iops   = 1,
--        bps    = 2,
--        qusize = 3,
--        await  = 4,
--        util   = 5,
--    }
--  ]]

local fifoSize = 60
local keys = {"iops", "bps", "qusize", "await", "util"}

local function addItem()
    return {
        baseThresh = {
            nrSample = 0,
            curWinMinVal = 1e9,
            curWinMaxVal = 0,
            moveAvg = 0,
            last = 0,
            thresh = 0
        },
        compensation = {
            thresh = 0,
            shouldUpdThreshComp = true,
            decRangeThreshAvg = 0,
            decRangeCnt = 0,
            minStableThresh = 1e9,
            maxStableThresh = 0,
            stableThreshAvg = 0,
            nrStableThreshSample = 0,
        },
        dynTresh = 1e9,
        usedWin = 0,
    }
end

local function addItems()
    local ret = {}
    for _, key in ipairs(keys) do
        ret[key] = addItem()
    end
    return ret
end

function CexecptCheck:_init_(diag)
    self._diag = diag

    self._fifo = CdiskFifo.new(fifoSize)
    self._waitItem = addItem()
    self._diskItem = {}

    self._cpuStatIowait = {sum = 0, iowait = 0}
    self._uploadInter = 0
    self._exceptionStat = {system = {['IOwait-High'] = {cur = 0, max = 0}}}
    self._dataStat = {system = {iowait= 0}}

    self._diagSwitch = {
        diagIowait = { sw = self._diag.cfg.diagIowait,
                       esi = 'IOwait-High'},
        diagIoburst = { sw = self._diag.cfg.diagIoburst,
                        esi ='IO-Delay'},
        diagIolat = {sw = self._diag.cfg.diagIolat,
                      esi = 'IO-Burst'},
        diagIohang = {sw = self._diag.cfg.diagIohang,
                       esi = 'IO-Hang'}
    }
end

local function calcBase(item, vs)
    local bt = item.baseThresh

    local min, max, avg, nr = vs.min, vs.max, vs.avg, vs.nr

    bt.nrSample     = nr
    bt.curWinMinVal = math.min(min, bt.curWinMinVal)
    bt.curWinMaxVal = math.max(max, bt.curWinMaxVal)
    bt.last         = vs.last

    local nrThreshSample = nr + 1 - fifoSize
    local thresh = math.max(max - avg, avg - min)
    local threshAvg = (bt.thresh * (nrThreshSample - 1) + thresh) / nrThreshSample
    bt.thresh  = threshAvg
    bt.moveAvg = avg

    local usedWin = item.usedWin
    usedWin = usedWin + 1
    if usedWin >= fifoSize then
        bt.curWinMinVal = 1e9
        bt.curWinMaxVal = 0
        item.usedWin = 0
    else
        item.usedWin = usedWin
    end
    return thresh
end

local function calcStableThresh(ct, curBaseThresh, curThresh)
    local avg = ct.decRangeThreshAvg

    if (curThresh - avg) < ((curBaseThresh - avg) / 10.0) then
        local nrStableThreshSample = ct.nrStableThreshSample

        local tSum = ct.stableThreshAvg * ct.nrStableThreshSample + curThresh
        nrStableThreshSample = nrStableThreshSample + 1

        ct.nrStableThreshSample = nrStableThreshSample
        ct.stableThreshAvg = tSum / nrStableThreshSample
        ct.minStableThresh = math.min(ct.minStableThresh, curThresh)
        ct.maxStableThresh = math.max(ct.maxStableThresh, curThresh)

        if nrStableThreshSample > fifoSize * 1.5 then
            ct.thresh = math.max(ct.stableThreshAvg - ct.minStableThresh,
                                    ct.maxStableThresh - ct.stableThreshAvg)
            ct.shouldUpdThreshComp = false
            ct.minStableThresh = 1e9
            ct.maxStableThresh = 0
            ct.stableThreshAvg, ct.decRangeThreshAvg = 0, 0
            ct.nrStableThreshSample, ct.decRangeCnt = 0, 0
        end
    end
end

local function calcCompThresh(item, lastBaseThresh, curThresh)
    local curBaseThresh = item.baseThresh.thresh
    local ct = item.compensation

    if ct.shouldUpdThreshComp and (ct.thresh < curThresh or item.usedWin == 0) then
        ct.thresh = curThresh
    end

    if curBaseThresh < lastBaseThresh then
        local decRangeCnt = ct.decRangeCnt
        local decRangeThreshAvg = ct.decRangeThreshAvg
        local tSum = decRangeThreshAvg * decRangeCnt + curThresh

        decRangeCnt = decRangeCnt + 1
        ct.decRangeThreshAvg = tSum / decRangeCnt
        ct.decRangeCnt = decRangeCnt

        if decRangeCnt >= fifoSize * 1.5 then
            calcStableThresh(ct, curBaseThresh, curThresh)
        else
            ct.minStableThresh = 1e9
            ct.maxStableThresh = 0
            ct.stableThreshAvg, ct.decRangeThreshAvg = 0, 0
            ct.nrStableThreshSample, ct.decRangeCnt = 0, 0
        end
    end
end

local function updateDynThresh(item, vs)
    local bt = item.baseThresh
    local ct = item.compensation
    local lastBaseThresh = bt.thresh
    local curThresh = calcBase(item, vs)

    calcCompThresh(item, lastBaseThresh, curThresh)
    item.dynTresh = bt.thresh + bt.moveAvg + ct.thresh
    --print("thresh: ", item.dynTresh)
end

function CexecptCheck:calcs()
    local iowaits = self._fifo:iowait()
    if iowaits then
        updateDynThresh(self._waitItem, iowaits)
        self:checkIOwaitException(self._waitItem)
    end

    local vs
    for disk, item in pairs(self._diskItem) do
        for _, key in ipairs(keys) do
            vs = self._fifo:values(disk, key)
            if vs then
                updateDynThresh(item[key], vs)
            end
        end
    end
end

function CexecptCheck:addValue(v)
    for disk, _ in pairs(v) do  -- new  iowait names one disk
        if disk ~= "iowait" then
            if not system:keyIsIn(self._diskItem, disk) then
                self._diskItem[disk] = addItems()
            end
        end
    end
    for disk, _ in pairs(self._diskItem) do    -- del
        if not system:keyIsIn(v, disk) then
            self._diskItem[disk] = nil
        end
    end
    self._fifo:push(v)
    self:calcs()
end

local function disableThreshComp(item)
    local ct = item.compensation
    local bt = item.baseThresh
    if ct.shouldUpdThreshComp then
        ct.shouldUpdThreshComp = false
        item.dynTresh = bt.thresh + bt.moveAvg
        ct.thresh = 0.000001
    end
end

function CexecptCheck:checkIOwaitException(item)
    local iowait = item.baseThresh.last
    local dataStat = self._dataStat.system
    local es = self._exceptionStat.system['IOwait-High']
    local uploadInter = self._uploadInter

    if iowait >= self._diag.cfg.iowait then
        disableThreshComp(item)
    end

    dataStat.iowait = (dataStat.iowait * (uploadInter - 1) + iowait) / uploadInter

    local minThresh = self._diag.cfg.iowait
    local iowaitThresh = math.max(item.dynTresh, minThresh)
    if minThresh >= iowaitThresh then
        es.cur = es.cur + 1
        local diagSW = self._diagSwitch.diagIowait
        local rDiagValid = nil
    end
end

function CexecptCheck:checks()
    local uploadInter = self._uploadInter

    if uploadInter % fifoSize == 0 then
        self._uploadInter = 1
    else
        self._uploadInter = uploadInter + 1
    end
end

return CexecptCheck
