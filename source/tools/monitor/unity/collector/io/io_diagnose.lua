---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/3/29 8:25 PM
---

require("common.class")
local CprotoData = require("common.protoData")
local CvProto = require("collector.vproto")
local CioDiagnose = class("ioDiagnose", CvProto)
local system = require("common.system")
local procffi = require("collector.native.procffi")
local pystring = require("common.pystring")
local unistd = require("posix.unistd")

local function ioWait(fStat)
    local data = procffi["ffi"].new("var_long_t")
    for line in io.lines(fStat) do
        local s = string.sub(line, 4)
        assert(procffi["cffi"].var_input_long(procffi["ffi"].string(s), data) == 0)
        break
    end
    local sum = 0
    for i = 0, data.no do
        sum = sum + tonumber(data.value[i])
    end

    return sum, tonumber(data.value[4])
end

local function diskExist(dirSys, disk)
    local path = dirSys .. disk
    return unistd.access(path)
end

local function distStat(fDisks)
    local disks = {}
    for line in io.lines(fDisks) do
        local s = pystring:split(line, nil, 3)[4]
        local data = procffi["ffi"].new("var_kvs_t")
        assert(procffi["cffi"].var_input_kvs(procffi["ffi"].string(s), data) == 0)
        local disk = procffi["ffi"].string(data.s)
        disks[disk] = data
    end
    return disks
end

local function pickValue(value)
    return {
        rws    = tonumber(value[1] + value[5]),
        rwSecs = tonumber(value[3] + value[7]),
        qusize = tonumber(value[11]),
        rwTiks = tonumber(value[4] + value[8]),
    }
end

function CioDiagnose:_init_(que, proto_q, fYaml, tid)
    CvProto._init_(self, CprotoData.new(que))
    self._tid  = tid
    local res = system:parseYaml(fYaml)
    self.fStat = res.config.proc_path .. "proc/stat"
    self.fDiskStat = res.config.proc_path .. "proc/diskstats"
    self.dirSys = res.config.proc_path .. "sys/block/"
    self._lastCpuTotal, self._lastCpuIO = ioWait(self.fStat)
    self._disks = {}
    self._disksLast = {}
    self:readProc()
    self:storeProc()
end

function CioDiagnose:readProc()
    local disks = distStat(self.fDiskStat)
    for disk, value in pairs(disks) do
        if diskExist(self.dirSys, disk) then
            self._disks[disk] = pickValue(value.value)
        else  -- not exist any more
            if self._disks[disk] then
                self._disks[disk] = nil
            end
        end
    end
end

function CioDiagnose:storeProc()
    self._disksLast = self._disks
    self._disks = {}
end

function CioDiagnose:diff(t)
    local res = {}
    for disk, value in pairs(self._disks) do
        local vLast = self._disksLast[disk]
        if vLast then
            local vs = {}
            for k, v in pairs(value) do
                vs[k] = (v - vLast[k]) / t
            end
            res[disk] = vs
        end
    end
    return res
end

function CioDiagnose:work(t)
    local cpuTotal, cpuIO = ioWait(self.fStat)
    --print( cpuTotal - self._lastCpuTotal, cpuIO - self._lastCpuIO)
    self._lastCpuTotal, self._lastCpuIO = cpuTotal, cpuIO

    self:readProc()
    local res = self:diff(t)
    --system:dumps(res)
    --system:dumps(self._disks)
    --system:dumps(self._disksLast)
    self:storeProc()
end

return CioDiagnose
