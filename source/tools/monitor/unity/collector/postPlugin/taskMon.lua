---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/3/27 11:46 AM
---

require("common.class")
local pystring = require("common.pystring")
local CvProc = require("collector.vproc")
local system = require("common.system")

local CtaskMon = class("taskMon", CvProc)

local function getInfo(fstat)
    local s
    for line in io.lines(fstat) do
        s = line
    end
    local ss = pystring:rsplit(s, ") ", 1)
    local comm = pystring:split(ss[1], "(", 1)

    local rest = ss[2]
    local vs = pystring:split(rest, " ")
    local user, sys = tonumber(vs[12]), tonumber(vs[13])
    return comm[2], user, sys
end

local function getStatus(fstatus)
    local ctxt1, ctxt2 = 0, 0
    for line in io.lines(fstatus) do
        if pystring:startswith(line, "voluntary_ctxt_switches") then
            local kvs = pystring:split(line)
            ctxt1 = tonumber(kvs[2])
        elseif pystring:startswith(line, "nonvoluntary_ctxt_switches") then
            local kvs = pystring:split(line)
            ctxt2 = tonumber(kvs[2])
        end
    end
    return ctxt1, ctxt2
end

function CtaskMon:_init_(proto, pffi, mnt, pid, loop)
    CvProc._init_(self, proto, pffi, mnt, nil)
    self._loop = loop or -1
    self._fstat = mnt .. 'proc/' .. pid .. '/stat'
    self._fstatus = mnt .. 'proc/' .. pid .. '/status'
    self._comm, self._lastUser, self._lastSys = getInfo(self._fstat)
    self._ls = {
        {
            name = "pid",
            index = tostring(pid),
        },
        {
            name = "comm",
            index = self._comm,
        },
    }
    self._ctxt, self._non_ctxt = getStatus(self._fstatus)
end

function CtaskMon:stat()
    local s
    for line in io.lines(self._fstat) do
        s = line
    end
    if s then
        local ss = pystring:rsplit(s, ") ", 1)
        local rest = ss[2]
        local vs = pystring:split(rest, " ")
        local user, sys = tonumber(vs[12]), tonumber(vs[13])
        local vsize, rss = tonumber(vs[21]), tonumber(vs[22])

        local ret = {
            {
                name = "vsize",
                value = vsize,
            },
            {
                name = "rss",
                value = rss * 4096,
            },
            {
                name = "user",
                value = user - self._lastUser
            },
            {
                name = "sys",
                value = sys  - self._lastSys
            },
        }
        self._lastUser = user
        self._lastSys  = sys
        return ret
    else
        return nil
    end
end

function CtaskMon:status(vs)
    for line in io.lines(self._fstatus) do
        if pystring:startswith(line, "voluntary_ctxt_switches") then
            local kvs = pystring:split(line)
            local v = tonumber(kvs[2])
            table.insert(vs, {name="voluntary_ctxt_switches", value = v - self._ctxt})
            self._ctxt = v
        elseif pystring:startswith(line, "nonvoluntary_ctxt_switches") then
            local kvs = pystring:split(line)
            local v = tonumber(kvs[2])
            table.insert(vs, {name="nonvoluntary_ctxt_switches", value = v - self._non_ctxt})
            self._non_ctxt = v
        end
    end
end

function CtaskMon:proc(elapsed, lines)
    local vs

    CvProc.proc(self)
    local ls = {{
        name = "pid",
        index = tostring(self.pid)
    }}

    vs = self:stat()
    if vs == nil then
        return -1
    end
    self:status(vs)
    system:dumps(vs)
    self:appendLine(self:_packProto("mon_task", self._ls, vs))
    self:push(lines)

    if self._loop > 0 then
        self._loop = self._loop - 1
        if self._loop <= 0 then
            return -1
        end
    end
end

return CtaskMon
