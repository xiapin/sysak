---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/8/12 9:37 PM
---

require("common.class")

local cjson = require("cjson.safe")
local system = require("common.system")
local json = cjson.new()

local foxFFI = require("tsdb.native.foxffi")
local CfoxTSDB = require("tsdb.foxTSDB")
local CfoxSQL = class("CfoxSQL",CfoxTSDB)

local code2err = {
    "no lower limit of time in where clauses" ,
    "bad time condition",
    "sql parse to req error",
    "bad label in where clause",
    "bas value in select clause"
}

function CfoxSQL:_init_(fYaml)
    CfoxTSDB._init_(self,fYaml)
end

function CfoxSQL:parse(sql)
    local ffi, cffi = foxFFI.ffi, foxFFI.cffi

    local pgRes = ffi.gc(ffi.new("PgQueryParseResult"), cffi.parse_sql_free)  -- will auto free by cffi.parse_sql_free

    cffi.parse_sql(sql, pgRes)
    local perror = pgRes.error
    local err = tonumber(ffi.cast("unsigned long", perror))
    if err ~= 0 then  -- is NULL
        return {
            error = ffi.string(perror.message),
            cursorpos = tonumber(perror.cursorpos),
        }
    else
        local s = ffi.string(pgRes.parse_tree)
        --print(s)
        system:dumps(json.decode(s))
        return json.decode(s)
    end
end

function CfoxSQL:hasTimeLimit(whereClause)
    if whereClause.A_Expr ~= nil then -- only one where
        if whereClause.A_Expr.lexpr.ColumnRef.fields[1].String.str == "time" then
            if whereClause.A_Expr.kind == "AEXPR_OP" then
                local op = whereClause.A_Expr.name[1].String.str
                if op == "<" or op == "<=" then
                    print("sql error: you must give a lower limit of time in where clauses")
                    return false
                end
            end
            return true
        else
            return false
        end
    end
    if whereClause.BoolExpr ~= nil then --not only one where condition
        local args = whereClause.BoolExpr.args
        for _, arg in ipairs(args) do
            if arg.A_Expr.lexpr.ColumnRef.fields[1].String.str == "time" then
                if arg.A_Expr.kind == "AEXPR_OP" then
                    local op = arg.A_Expr.name[1].String.str
                    if op == "<" or op == "<=" then
                        print("sql error: you must give a lower limit of time in where clauses")
                        return false
                    end
                end

                return true
            end
        end

    end
    return false
end

function CfoxSQL:parseLabelsLimit(args)
    local res = {}
    for _, arg in ipairs(args) do
        if arg.A_Expr.lexpr.ColumnRef.fields[1].String.str ~= "time" then
            if arg.A_Expr.name[1].String.str ~= "=" then
                print("sql error: only support equal in where condition")
            else
                local k = arg.A_Expr.lexpr.ColumnRef.fields[1].String.str
                local v = arg.A_Expr.rexpr.ColumnRef.fields[1].String.str
                res[k] = v
            end
        end
    end
    return res
end


function CfoxSQL:parseSqlToReq(sql)
    local res = {}
    local req = {}
    local SelectStmt = sql.stmts[1].stmt.SelectStmt
    local fromClauses = SelectStmt.fromClause
    local fromtbls = {}

    local c = 1
    if fromClauses ~= nil then
        for _, fromClause in ipairs(fromClauses) do
            fromtbls[c] = fromClause.RangeVar.relname
            c = c + 1
        end
    end
    req["fromtbls"] = fromtbls

    local targetLists = SelectStmt.targetList
    local targetvals = {}
    c = 1
    if type(targetLists[1].ResTarget.val.ColumnRef.fields[1].A_Star) == "table" then
        req["selectAll"] = true
    else
        req["selectAll"] = false
        for _, targetList in ipairs(targetLists) do
            targetvals[c] = targetList.ResTarget.val.ColumnRef.fields[1].String.str
            c = c + 1
        end

    end
    req["targetvals"] = targetvals

    local whereClause = SelectStmt.whereClause
    req["labelsLimit"] = {}

    if type(whereClause.A_Expr) == "table" then -- only one where
        print("only one where")
        if whereClause.A_Expr.kind == "AEXPR_OP" then --example：WHERE time > NOW(-10)
            local op = whereClause.A_Expr.name[1].String.str
            local secs = 0
            if type(whereClause.A_Expr.rexpr.FuncCall) == "table"  and whereClause.A_Expr.rexpr.FuncCall.funcname[1].String.str == "now" then
                local args = whereClause.A_Expr.rexpr.FuncCall.args
                --assert(args[1].A_Const.val.Integer ~= nil,"now arg error")
                if args[1].A_Const.val.Integer == nil then
                    print("now arg error")
                    res["code"] = -2
                    return res
                end
                secs = args[1].A_Const.val.Integer.ival
                secs = math.abs(secs)
                --ms = self:qNow(secs,fromtbls)
            else
                print("sql error: you must time conditon like 'time > NOW(-secs)'")
                res["code"] = -2
                return res
            end
            req["mode"] = "last"
            req["secs"] = secs
        elseif whereClause.A_Expr.kind == "AEXPR_BETWEEN" then
            local start = whereClause.A_Expr.rexpr.List.items[1].A_Const.val.String.str
            local stop = whereClause.A_Expr.rexpr.List.items[2].A_Const.val.String.str

            print("between " .. start .. " and " .. stop)
            local dstart = self:str2date(start)
            local dstop = self:str2date(stop)
            if dstart == nil or dstop == nil then
                res["code"] = -2
                return res
            end
            req["mode"] = "date"
            req["start"] = dstart
            req["stop"] = dstop
        end

    elseif type(whereClause.BoolExpr) == "table" then --not only one where condition
        local args = whereClause.BoolExpr.args
        local lbs = self:parseLabelsLimit(args)
        req["labelsLimit"] = lbs
        for _, arg in ipairs(args) do
            if arg.A_Expr.lexpr.ColumnRef.fields[1].String.str == "time" then
                if arg.A_Expr.kind == "AEXPR_OP" then --example：WHERE time > NOW(-10)
                    local op = arg.A_Expr.name[1].String.str
                    local secs = 0
                    if type(arg.A_Expr.rexpr.FuncCall)  == "table" and arg.A_Expr.rexpr.FuncCall.funcname[1].String.str == "now" then
                        local as = arg.A_Expr.rexpr.FuncCall.args
                        assert(as[1].A_Const.val.Integer ~= nil,"now arg error")
                        if as[1].A_Const.val.Integer == nil then
                            print("now arg error")
                            res["code"] = -2
                            return res
                        end
                        secs = as[1].A_Const.val.Integer.ival
                        secs = math.abs(secs)
                        --ms = self:qNow(secs,fromtbls)
                        req["mode"] = "last"
                        req["secs"] = secs
                    else
                        print("sql error: you must time conditon like 'time > NOW(-secs)'")
                        res["code"] = -2
                        return res
                    end

                elseif arg.A_Expr.kind == "AEXPR_BETWEEN" then
                    local start = arg.A_Expr.rexpr.List.items[1].A_Const.val.String.str
                    local stop = arg.A_Expr.rexpr.List.items[2].A_Const.val.String.str

                    print("between " .. start .. " and " .. stop)
                    local dstart = self:str2date(start)
                    local dstop = self:str2date(stop)
                    --ms = self:qDate(dstart,dstop,fromtbls)
                    if dstart == nil or dstop == nil then
                        res["code"] = -2
                        return res
                    end
                    req["mode"] = "date"
                    req["start"] = dstart
                    req["stop"] = dstop
                end
                break
            end
        end

    end
    system:dumps(req)
    print("return req")
    res["code"] = 0
    res["req"] = req
    return res
end

function CfoxSQL:selectTables(req,ms)
    local finalres = {}
    local res = {}
    if req == {} then
        print("req is nil")
        finalres["code"] = -3
        finalres["ms"] = {}
        return finalres
    end

    if req["mode"] == "last" then
        local fromtbls = req["fromtbls"]
        local secs = req["secs"]
        if fromtbls == {} then
            ms = self:qNow(secs)
        else
            ms = self:qNow(secs,fromtbls)
        end

        print("select last ")
    elseif req["mode"] == "date" then
        local fromtbls = req["fromtbls"]
        local dstart = req["start"]
        local dstop = req["stop"]
        if fromtbls == {} then
            ms = self:qDate(dstart,dstop)
        else
            ms = self:qDate(dstart,dstop,fromtbls)
        end

        print("select data ")
    end
    finalres["code"] = 0
    finalres["ms"] = ms
    return finalres
end

function CfoxSQL:selectLabels(req,ms)
    local finalres = {}
    local res = {}
    if req == {} then
        print("req is nil")
        finalres["code"] = -3
        finalres["ms"] = {}
        return finalres
    end
    if req["labelsLimit"] == {} then
        print("there is no labels limit")
        finalres["code"] = 0
        finalres["ms"] = ms
        return finalres
    end
    for _, line in ipairs(ms) do
        local match = true
        for k,v in pairs(req["labelsLimit"]) do
            if system:keyIsIn(line["labels"],k)==false then
                finalres["code"] = -4
                finalres["ms"] = {}
                return finalres
            elseif line["labels"][k] ~= v then
                match = false
            end

        end
        if match then
            table.insert(res,line)
        end

    end
    finalres["code"] = 0
    finalres["ms"] = res
    return finalres
end

function CfoxSQL:selectVals(req,ms)
    local finalres = {}
    local res = {}
    if req == {} then
        print("req is nil")
        finalres["code"] = -3
        finalres["ms"] = {}
        return finalres
    end
    if req["selectAll"] == true then
        finalres["code"] = 0
        finalres["ms"] = ms
        return finalres

    else

        for _, line in ipairs(ms) do
            local lineres = {}
            for k,v in pairs(line) do
                if k ~= "values" then
                    lineres[k] = v
                else
                    local vs = {}
                    for _, targetval in ipairs(req["targetvals"]) do
                        if system:keyIsIn(v,targetval) then
                            vs[targetval] = v[targetval]
                        else
                            finalres["code"] = -5
                            finalres["ms"] = {}
                            return finalres
                        end
                    end
                    lineres["values"] = vs
                end
            end
            table.insert(res,lineres)
        end

    end
    finalres["code"] = 0
    finalres["ms"] = res
    return finalres
end

function CfoxSQL:getDateFromTime(ms)
    --local finalres = {}
    for _,line in ipairs(ms) do
        local time = line["time"]
        local date = self:getDateFrom_us(tonumber(time))
        --line["time"] = self:date2str(date)
        line["time"] = os.date("%x %X", tonumber(time) / 1000000)
    end
    return ms
end

function CfoxSQL:select(sql) -- make sure that sql.stmts[1].stmt.SelectStmt~=nil
    local ms = {}
    local res = {
        status = "ok",
        error = "",
        data = {}
    }
    if self:hasTimeLimit(sql.stmts[1].stmt.SelectStmt.whereClause) then
        local req = {}
        local tmp = self:parseSqlToReq(sql,req)
        local code = tmp["code"]
        if code ~= 0 then
            res["status"] = "failed"
            code = math.abs(code)
            res["error"] = code2err[code]
            return res
        end
        req = tmp["req"]
        system:dumps(req)

        tmp = self:selectTables(req,ms)
        code = tmp["code"]
        if code ~= 0 then
            res["status"] = "failed"
            code = math.abs(code)
            res["error"] = code2err[code]
            return res
        end
        ms = tmp["ms"]
        system:dumps(ms)

        tmp = self:selectVals(req,ms)
        code = tmp["code"]
        if code ~= 0 then
            res["status"] = "failed"
            code = math.abs(code)
            res["error"] = code2err[code]
            return res
        end
        ms = tmp["ms"]
        system:dumps(ms)

        tmp = self:selectLabels(req,ms)
        code = tmp["code"]
        if code ~= 0 then
            res["status"] = "failed"
            code = math.abs(code)
            res["error"] = code2err[code]
            return res
        end
        ms = tmp["ms"]
        system:dumps(ms)

        ms = self:getDateFromTime(ms)
        --code = tmp["code"]
        --if code ~= 0 then
        --    res["status"] = "failed"
        --    code = math.abs(code)
        --    res["error"] = code2err[code]
        --    return res
        --end
        --ms = tmp["ms"]
        system:dumps(ms)

        res["data"] = ms
        return res
    else
        print("sql error: you must give one time condition in where clauses")
        res["status"] = "failed"
        res["error"] = code2err[1]
        return res
    end


end

function CfoxSQL:show(sql)

end

function CfoxSQL:sql(sql)
    local SelectStmt = sql.stmts[1].stmt.SelectStmt
    local VariableShowStmt = sql.stmts[1].stmt.VariableShowStmt
    if SelectStmt ~= nil then
        print("sql select")
        return self:select(sql)
    elseif VariableShowStmt ~= nil then
        print("sql show")
        return self:show(sql)

    end

end

return CfoxSQL
