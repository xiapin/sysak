---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/4/3 17:46
---

require("common.class")
local enumStat = require("httplib.enumStat")
local system = require("common.system")
local unistd = require("posix.unistd")
local CprotoData = require("common.protoData")
require("struct")
local CcoCli = class("coFrame")

function CcoCli:_init_(fd)
    self._bfd = fd
    self._efd = self:_installFFI()
    self._proto = CprotoData.new(nil)
end

function CcoCli:_del_()
    if self._efd then
        self.cffi.deinit(self._efd)
    end
end

function CcoCli:_installFFI()
    local ffi = require("beaver.native.beavercffi")

    self.ffi = ffi.ffi
    self.cffi = ffi.cffi

    local efd = self.cffi.init(self._bfd)
    assert(efd > 0)
    return efd
end

local socketWakeTbl = {
    enumStat.connected,
    enumStat.closed,
}

function CcoCli:filterLines(cli, lines, body)
    return cli:trans(lines, body, nil)
end

function CcoCli:coQueFunc(cli, cffi, efd)
    local body
    local ok, msg
    while true do
        local lines = coroutine.yield()
        local stat = cli.status
        if lines and #lines.lines > 0 then
            body = self:filterLines(cli, lines, body)
        end
        if body then   --> has data to send.
            if cli.co == nil and stat == enumStat.closed then  -- not active
                local co = coroutine.create(function(c, o, fd) cli.work(c, o, fd)  end)
                cli.co = co
                ok, msg = coroutine.resume(co, cli, cffi, efd)
                if not ok then
                    error(string.format("cli.co run failed %s", msg))
                end
            elseif stat == enumStat.connected then  --> already connected
                ok, msg = coroutine.resume(cli.co, body)
                if not ok then
                    error(string.format("cli.co run failed %s", msg))
                end
                body = nil
            else  --> other stat, only record
                ok = nil
                --print("http stat:", stat, enumStat.connected)
            end
        end
    end
end

function CcoCli:checkOvertime(cli, co, ffi)
    local ok, msg
    if cli.status == enumStat.connecting and cli:checkTime() >= 2 then
        local e = ffi.new("native_event_t")
        e.fd = cli.fd
        e.ev_close = 1
        ok, msg = coroutine.resume(cli.co, e)  --> to stop cli connecting
        if not ok then
            error(string.format("cli.co run failed %s", msg))
        end
        coroutine.resume(co, "")  --> notify que
        if not ok then
            error(string.format("coOut run failed %s", msg))
        end
    end
end

local function err_fd(e)
    if e.ev_close > 0 then
        error("pipe out closed, process need stop.")
    end
end

local function pipe_error(err, errno)
    error(string.format("read from pipe error: %s, %d", err, errno))
end

local function read_stream(fd)
    local out
    while true do
        local e = coroutine.yield(out)
        out = nil  -- clear out
        err_fd(e)
        local size, err, errno = unistd.read(fd, 4)
        if size then
            local c = 0
            local len = struct.unpack("<i", size)
            local ss_len = 0
            local ss = {}

            while ss_len < len do
                local s
                s, err, errno = unistd.read(fd, len - ss_len)
                if s then
                    c = c + 1
                    ss[c] = s
                    ss_len = ss_len + #s
                    if ss_len == len then
                        out = table.concat(ss)
                    else
                        e = coroutine.yield()
                        err_fd(e)
                    end
                else
                    pipe_error(err, errno)
                end
            end
        else
            pipe_error(err, errno)
        end
    end
end

function CcoCli:pushMsg(coOut, bytes)
    local ok, msg
    local lines = self._proto:decode(bytes)

    ok, msg = coroutine.resume(coOut, lines)
    if not ok then
        print(string.format("coOut run failed %s, check your yaml", msg))
    end
    return ok
end

function CcoCli:_newOut(cli)
    local coOut = coroutine.create(self.coQueFunc)
    local ok, msg = coroutine.resume(coOut, self, cli, self.cffi, self._efd, coOut)
    if not ok then
        error(string.format("coOut run failed %s", msg))
        return nil
    end
    return coOut
end

function CcoCli:_pollFd(bfd, cli, nes, coIn, coOut)
    local ok, msg
    for i = 0, nes.num - 1 do
        local e = nes.evs[i];
        local fd = e.fd
        if fd == bfd then
            ok, msg = coroutine.resume(coIn, e)
            if ok then
                if msg then
                    ok = self:pushMsg(coOut, msg)
                    if not ok then
                        coOut = self:_newOut(cli)
                        assert(coOut)
                    end
                end
            else
                error(string.format("coIn run failed %s", msg))
            end
        elseif fd == cli.fd then
            ok, msg = coroutine.resume(cli.co, e)
            if not ok then
                error(string.format("cli.co run failed %s", msg))
            end
            if system:valueIsIn(socketWakeTbl, cli.status) then
                ok, msg = coroutine.resume(coOut, nil)
                if not ok then
                    error(string.format("coOut run failed %s", msg))
                end
            end
        else
            print("bad fd " .. fd .. "use fd " .. cli.fd)
        end
    end
    return coOut
end

function CcoCli:_poll(cli)
    local ok, msg
    local bfd = self._bfd
    local efd = self._efd
    local ffi, cffi = self.ffi, self.cffi

    --local coOut = coroutine.create(self.coQueFunc)
    --ok, msg = coroutine.resume(coOut, self, cli, cffi, efd, coOut)
    --if not ok then
    --    error(string.format("coOut run failed %s", msg))
    --end

    local coOut = self:_newOut(cli)
    assert(coOut)

    local coIn = coroutine.create(read_stream)
    ok, msg = coroutine.resume(coIn, bfd)
    if not ok then
        error(string.format("coIn run failed %s", msg))
    end

    while true do
        local nes = ffi.new("native_events_t")
        local res = cffi.poll_fds(efd, 1, nes)

        if res < 0 then
            return "end poll."
        end
        if nes.num > 0 then
            coOut = self:_pollFd(bfd, cli, nes, coIn, coOut)
        else
            self:checkOvertime(cli, coOut, ffi)
        end
    end
end

function CcoCli:poll(cli)
    local _, msg = pcall(self._poll, self, cli)
    print(msg)
    return 0
end

return CcoCli
