---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/4/3 17:46
---

require("common.class")
local enumStat = require("httplib.enumStat")
local system = require("common.system")
local CcoCli = class("coFrame")

function CcoCli:_init_(fd)
    self._bfd = fd
    self._efd = self:_installFFI()
end

function CcoCli:_del_()
    if self._efd then
        self.cffi.deinit(self._efd)
    end
end

function CcoCli:_installFFI()
    local ffi = require("beaver.native.beavercffi")

    self.ffi = ffi.ffi
    self.cffi = ffi.cffi

    local efd = self.cffi.init(self._bfd)
    assert(efd > 0)
    return efd
end

local socketWakeTbl = {
    enumStat.connected,
    enumStat.closed,
}

local function coQueFunc(cli, cffi, efd)
    local data
    while true do
        local msg = coroutine.yield()
        local stat = cli.status
        if #msg > 0 then
            data = msg
        end
        if data then   --> has data to send.
            if cli.co == nil and stat == enumStat.closed then  -- not active
                local co = coroutine.create(function(c, o, fd) cli.work(c, o, fd)  end)
                cli.co = co
                coroutine.resume(co, cli, cffi, efd)
            elseif stat == enumStat.connected then  --> already connected
                coroutine.resume(cli.co, data)
                data = nil
            else  --> other stat, only record
                print(stat, enumStat.connected)
            end
        end
    end
end

function CcoCli:checkOvertime(cli, co, ffi)
    if cli.status == enumStat.connecting and cli:checkTime() >= 2 then
        local e = ffi.new("native_event_t")
        e.fd = cli.fd
        e.ev_close = 1
        coroutine.resume(cli.co, e)  --> to stop cli connecting
        coroutine.resume(co, "")  --> notify que
    end
end

function CcoCli:_pollFd(bfd, cli, nes, co)
    for i = 0, nes.num - 1 do
        local e = nes.evs[i];
        local fd = e.fd
        if fd == bfd then
            print("bfd worked.")
        elseif fd == cli.fd then
            coroutine.resume(cli.co, e)
            if system:valueIsIn(socketWakeTbl, cli.status) then
                coroutine.resume(co, "")
            end
        else
            print("bad fd " .. fd .. "use fd " .. cli.fd)
        end
    end
end

function CcoCli:_poll(cli)
    local bfd = self._bfd
    local efd = self._efd
    local ffi, cffi = self.ffi, self.cffi

    local co = coroutine.create(coQueFunc)
    coroutine.resume(co, cli, cffi, efd, co)

    local c = 1
    while true do
        local nes = ffi.new("native_events_t")
        local res = cffi.poll_fds(efd, 1, nes)

        if res < 0 then
            return "end poll."
        end
        if nes.num > 0 then
            self:_pollFd(bfd, cli, nes, co)
        else
            print("start.")
            coroutine.resume(co, "hello." .. c)
            c = c + 1
            self:checkOvertime(cli, co, ffi)
        end
    end
end

function CcoCli:poll(cli)
    local _, msg = pcall(self._poll, self, cli)
    print(msg)

    return 0
end

return CcoCli
