---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/4/3 11:42
---

require("common.class")
local ChttpComm = require("httplib.httpComm")
local enumStat = require("httplib.enumStat")
local pystring = require("common.pystring")
local socket = require("posix.sys.socket")
local luaSocket = require("socket")
local unistd = require("posix.unistd")
local system = require("common.system")
local bit = require("bit")
local fcntl = require("posix.fcntl")

local CcoHttpCli = class("coHttpCli", ChttpComm)

local ip_pattern = "(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)"

local function match_ip(ip)
    local d1, d2, d3, d4 = ip:match(ip_pattern)
    if d1 and d2 and d3 and d4 then
        local num1, num2, num3, num4 = tonumber(d1), tonumber(d2), tonumber(d3), tonumber(d4)
        if num1 >= 0 and num1 <= 255 and num2 >= 0 and num2 <= 255 and num3 >= 0 and num3 <= 255 and num4 >= 0 and num4 <= 255 then
            return true
        end
    end
    return false
end

local function checkInt(errno, fd)
    if errno == 4 then -- Interrupted system cal
        if fd > 0 then
            unistd.close(fd)
        end
        error("cli interrupt.")
    end
end

local function getIp(host)
    local ip
    if match_ip(host) then
        ip = host
    else
        ip = luaSocket.dns.toip(host)
    end
    return ip
end

local function setTimeOut(fd)
    local ok, errmsg = socket.setsockopt(fd, socket.SOL_SOCKET, socket.SO_SNDTIMEO, 1, 0)
    if ok then
        return
    else
        print("set sock time out failed " .. errmsg)
        return -1
    end
end

local function fdNonBlocking(fd)
    local res
    local flag, err, errno = fcntl.fcntl(fd, fcntl.F_GETFL)
    if flag then
        res, err, errno = fcntl.fcntl(fd, fcntl.F_SETFL, bit.bor(flag, fcntl.O_NONBLOCK))
        if res then
            return
        else
            checkInt(errno, fd)
            print(string.format("fcntl set failed, report:%d, %s", err, errno))
            return -1
        end
    else
        checkInt(errno, fd)
        print(string.format("fcntl get failed, report:%d, %s", err, errno))
        return -1
    end
end

local function installFd(ip, port)
    local fd, res, err, errno
    fd, err, errno = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)

    if fd then  -- for socket
        if fdNonBlocking(fd) then
            return
        end
        local tConn = {family=socket.AF_INET, addr=ip, port=port}
        res, err, errno = socket.connect(fd, tConn)
        if res then
            return fd, res
        elseif errno == 115 then  -- in process
            return fd, errno
        else
            checkInt(errno, fd)
            unistd.close(fd)
            print(string.format("socket connect failed, report:%d, %s", err, errno))
            end
    else  -- socket failed
        checkInt(errno, 0)
        print(string.format("socket create failed, report:%d, %s", err, errno))
    end
end

local function setupSocket(host, port)
    local ip = getIp(host)
    if ip then
        return installFd(ip, port)
    else
        print("get ip failed.")
        return nil
    end
end

function CcoHttpCli:_init_(fYaml, persistent)
    local res = system:parseYaml(fYaml)
    local pushTo = res.pushTo
    self._host = pushTo.host
    self._port = pushTo.port or 80
    self._url = pushTo.url or "/"
    self._persistent = persistent

    local Cidentity = require("beaver.identity")
    local inst = Cidentity.new(fYaml)
    self._instance = inst:id()

    self.status = enumStat.closed
end

function CcoHttpCli:connect()
    local fd, stat
    fd, stat = setupSocket(self._host, self._port)
    if fd then
        self.fd = fd
        if stat == 0 then
            self.status = enumStat.connected
        else
            self.status = enumStat.connecting
        end
        return true
    end
    return false
end

function CcoHttpCli:echo(tReq)
    print("clid get " .. #tReq.data)
end

function CcoHttpCli:trans(msgs, body, filter)
    return ""
end

function CcoHttpCli:addInstance(line)   -- add instance id for line index.
    local cells = line.ls
    local hasInstance = false

    if cells then
        for _, cell in ipairs(cells) do
            if cell.name == "instance" then
                hasInstance = true
            end
        end
    end

    if not hasInstance then
        local cell = {
            name = "instance",
            index = self._instance
        }
        if cells then
            table.insert(cells, cell)
        else
            line.ls = {cell}
        end
    end
end

function CcoHttpCli:pack(body)
    local line = self:packCliHead('GET', self._url)
    local head = {
        Host = self._host,
        ["Accept-Encoding"] = "null"
    }
    local heads = self:packCliHeaders(head)
    return pystring:join("\r\n", {line, heads, ""})
end

function CcoHttpCli:waitConnected(cffi, efd)
    local e
    local res
    local fd = self.fd
    if self.status == enumStat.connecting then  -- need wait until connected
        res = cffi.mod_fd(efd, fd, 1)
        checkInt(-res, fd)
        if res < 0 then
            print("mod_fd socket failed")
            return false
        end

        e = coroutine.yield()
        if e.ev_close > 0 then
            print("socket closed.")
            return false
        elseif e.ev_out > 0 then  -- in flag
            local val, err, errno = socket.getsockopt(fd, socket.SOL_SOCKET, socket.SO_ERROR)
            if val == nil then
                print(string.format("getsockopt failed, report:%d, %s", err, errno))
                return false
            elseif val == 0 then
                self.status = enumStat.connected
                res = cffi.mod_fd(efd, fd, 0)  -- back to wait mod,
                checkInt(-res, fd)
                if res < 0 then
                    print("mod_fd socket failed")
                    return false
                end
                return true
            else
                checkInt(errno, fd)
                print("getsockopt value error.")
                return false
            end
        end
    end
    return true
end

function CcoHttpCli:exit(cffi, efd, fd)
    local  res = cffi.del_fd(efd, fd)  -- remove for epoll
    unistd.close(fd)  -- closed
    checkInt(-res, fd)
    self.co = nil
    self.fd = nil     -- do not use any more
end

local function waitDataRest(fread, rest, tReq)
    local len = 0
    local tStream = {tReq.data}
    local c = #tStream
    while len < rest do
        local s = fread()
        if s then
            len = len + #s
            c = c + 1
            tStream[c] = s
        else
            return -1
        end
    end
    tReq.data = pystring:join("", tStream)
    return 0
end

local function waitChuckData(fread, s, size)
    while true do
        if #s >= size + 2 then
            return s
        end
        local add = fread()
        if add then
            s = s .. add
        else
            return nil
        end
    end
end

local function waitChuckSize(fread, s)
    while true do
        if string.find(s, "\r\n") then
            return s
        end
        local add = fread()
        if add then
            s = s .. add
        else
            return nil
        end
    end
end

local function readChunks(fread, tReq)
    local cells = {}
    local s = tReq.data
    local ssize, size
    local len = 1
    local bodies, body

    while true do
        if len == 0 then
            break
        end
        s = waitChuckSize(fread, s)
        if s then
            size, s = unpack(pystring:split(s, "\r\n", 1))
            len = tonumber(size, 16)
            bodies = waitChuckData(fread, s, len)
            if bodies then
                body = string.sub(bodies, 1, len)
                s = string.sub(bodies, len + 2)
                table.insert(cells, body)
            else
                return -2
            end
        else
            return -1
        end
    end
    tReq.data = pystring:join("", cells)
    return 0
end

local function waitHttpRest(fread, tReq)
    if tReq.header["content-length"] then
        local lenData = #tReq.data
        local lenInfo = tonumber(tReq.header["content-length"])
        print("len: " .. lenInfo)

        local rest = lenInfo - lenData
        if rest > 10 * 1024 * 1024 then  -- limit max data len
            return -1
        end

        if waitDataRest(fread, rest, tReq) < 0 then
            return -2
        end
    else  -- chunk mode
        if #tReq.data > 0 then
            if readChunks(fread, tReq) < 0 then
                return -3
            end
        end
    end
    return 0
end

local function waitHttpHead(fread)
    local stream = ""
    while true do
        local s = fread()
        if s then
            stream = stream .. s
            if string.find(stream, "\r\n\r\n") then
                return stream
            end
        else
            return nil
        end
    end
end

function CcoHttpCli:parse(fread, stream)
    local tStatus = pystring:split(stream, "\r\n", 1)
    if #tStatus < 2 then
        print("bad stream format.")
        return nil
    end

    local stat, heads = unpack(tStatus)
    local tStat = pystring:split(stat, " ")
    if #tStat < 3 then
        print("bad stat: "..stat)
        return nil
    end

    local vers, code, descr = unpack(tStat)
    local tReq = {
        vers = vers,
        code = code,
        descr = descr
    }

    local tHead = pystring:split(heads, "\r\n\r\n", 1)
    if #tHead < 2 then
        print("bad head: " .. heads)
        return nil
    end
    local headers, data = unpack(tHead)
    local tHeader = pystring:split(headers, "\r\n")
    local header = {}
    for _, s in ipairs(tHeader) do
        local tKv = pystring:split(s, ":", 1)
        if #tKv < 2 then
            print("bad head kv value: " .. s)
            return nil
        end
        local k, v = unpack(tKv)
        k = string.lower(k)
        header[k] = pystring:lstrip(v)
    end
    tReq.header = header
    tReq.data = data
    if waitHttpRest(fread, tReq) < 0 then
        return nil
    end
    return tReq
end

function CcoHttpCli:result(fread)
    local stream = waitHttpHead(fread)
    if stream == nil then   -- read return stream or error code or nil
        return nil
    end
    return self:parse(fread, stream)
end

function CcoHttpCli:closureRead(fd, maxLen)
    maxLen = maxLen or 1 * 1024 * 1024  -- signal conversation accept 1M stream max
    local function readFd()
        local e = coroutine.yield()
        if e.ev_close > 0 then
            return nil
        elseif e.ev_in > 0 then
            local s, err, errno
            s, err, errno = socket.recv(fd, maxLen)
            if s then
                if #s > 0 then
                    maxLen = maxLen - #s
                    return s
                else
                    return nil
                end
            else
                checkInt(errno, fd)
                print(string.format("socket recv failed, report:%d, %s", err, errno))
                return nil
            end
        else
            system:dumps(e)
        end
        return nil
    end
    return readFd
end

function CcoHttpCli:coWrite(cffi, efd, fd, stream)
    local sent, err, errno
    local res

    sent, err, errno = socket.send(fd, stream)
    if sent ~= nil then
        if sent < #stream then  -- send buffer may full
            res = cffi.mod_fd(efd, fd, 1)  -- epoll write ev
            checkInt(-res, fd)
            if res < 0 then
                print("mod_fd socket failed")
                return false
            end

            while sent < #stream do
                print("send.", sent, #stream)
                local e = coroutine.yield()
                if e.ev_close > 0 then
                    return false
                elseif e.ev_out then
                    stream = string.sub(stream, sent + 1)
                    if stream == nil then
                        return true
                    end
                    sent, err, errno = socket.send(fd, stream)
                    if sent == nil then
                        if errno == 11 then  -- EAGAIN ?
                            goto continue
                        end
                        checkInt(errno, fd)
                        print(string.format("socket send failed, report:%d, %s", err, errno))
                        return false
                    end
                else  -- need to read ? may something error or closed.
                    return false
                end
                ::continue::
            end
            res = cffi.mod_fd(efd, fd, 0)  -- epoll read ev only
            checkInt(-res, fd)
            if res < 0 then
                print("mod_fd socket failed")
                return false
            end
        end
        return true
    else
        checkInt(errno, fd)
        print(string.format("socket send failed, report:%d, %s", err, errno))
        return false
    end
end

function CcoHttpCli:checkTime()
    return os.time() - self.online
end

function CcoHttpCli:work(cffi, efd)
    self.online = os.time()

    if not self:connect() then  -- need to connect
        return
    end

    local fd = self.fd

    local res = cffi.add_fd(efd, fd)
    checkInt(-res, fd)
    if res < 0 then
        print("add fd to epoll failed.")
        goto failed
    end

    if not self:waitConnected(cffi, efd) then
        goto failed
    end

    self.online = os.time()
    while true do
        local body = coroutine.yield()
        self.status = enumStat.sending
        local s = self:pack(body)
        if not self:coWrite(cffi, efd, fd, s) then
            goto failed
        end
        self.status = enumStat.receiving
        local fread = self:closureRead(fd)
        local tReq = self:result(fread)
        if tReq then
            self.status = enumStat.connected
            self:echo(tReq)
        else
            goto failed
        end
        if not self._persistent then
            goto failed
        end
    end

    ::failed:: do
        self.status = enumStat.closed
        self:exit(cffi, efd, fd)
    end
end

return CcoHttpCli
