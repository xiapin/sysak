---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2023/5/24 15:38
---

require("common.class")
local ChttpComm = require("httplib.httpComm")
local pystring = require("common.pystring")
local psocket = require("posix.sys.socket")
local unistd = require("posix.unistd")
local bit = require("bit")
local fcntl = require("posix.fcntl")
local CasyncDns = require("httplib.asyncDns")

local CasyncHttp = class("asyncHttp", ChttpComm)

local ip_pattern = "(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)%.(%d%d?%d?)"

local function match_ip(ip)
    local d1, d2, d3, d4 = ip:match(ip_pattern)
    if d1 and d2 and d3 and d4 then
        local num1, num2, num3, num4 = tonumber(d1), tonumber(d2), tonumber(d3), tonumber(d4)
        if num1 >= 0 and num1 <= 255 and num2 >= 0 and num2 <= 255 and num3 >= 0 and num3 <= 255 and num4 >= 0 and num4 <= 255 then
            return true
        end
    end
    return false
end

local function getIp(domain)
    local ip
    if match_ip(domain) then
        ip = domain
    else
        local dns = CasyncDns.new()
        ip = dns:dns_lookup(domain)
    end
    return ip
end

local function fdNonBlocking(fd)
    local res
    local flag, err, errno = fcntl.fcntl(fd, fcntl.F_GETFL)
    if flag then
        res, err, errno = fcntl.fcntl(fd, fcntl.F_SETFL, bit.bor(flag, fcntl.O_NONBLOCK))
        if res then
            return
        else
            print(string.format("fcntl set failed, report:%d, %s", err, errno))
            return -1
        end
    else
        print(string.format("fcntl get failed, report:%d, %s", err, errno))
        return -1
    end
end

local function setupFd()
    local fd, err, errno
    fd, err, errno = psocket.socket(psocket.AF_INET, psocket.SOCK_STREAM, 0)
    if fd then  -- for socket
        if fdNonBlocking(fd) == -1 then
            unistd.close(fd)
            return -1
        end
        return fd
    else
        print(string.format("socket create failed, report:%d, %s", err, errno))
        return -1
    end
end

local function tryConnect(fd, tConn)
    local res, err, errno

    res, err, errno = psocket.connect(fd, tConn)
    if not res then
        if errno == 115 then
            return 1
        else
            print(string.format("socket connect failed, report:%d, %s", errno, err))
            return
        end
    else
        return 0
    end
end

function CasyncHttp:_init_()
    ChttpComm._init_(self)
end

function CasyncHttp:pack(method, domain, uri, headers, body)
    local line = self:packCliHead(method, uri)
    headers.Host = domain
    headers = self:packCliHeaders(headers, #body)
    return pystring:join("\r\n", {line, headers, body})
end

local function waitDataRest(fread, rest, tReq)
    local len = 0
    local tStream = {tReq.data}
    local c = #tStream
    while len < rest do
        local s = fread()
        if s then
            len = len + #s
            c = c + 1
            tStream[c] = s
        else
            return -1
        end
    end
    tReq.data = pystring:join("", tStream)
    return 0
end

local function waitChuckData(fread, s, size)
    while true do
        if #s >= size + 2 then
            return s
        end
        local add = fread()
        if add then
            s = s .. add
        else
            return nil
        end
    end
end

local function waitChuckSize(fread, s)
    while true do
        if string.find(s, "\r\n") then
            return s
        end
        local add = fread()
        if add then
            s = s .. add
        else
            return nil
        end
    end
end

local function readChunks(fread, tReq)
    local cells = {}
    local s = tReq.data
    local ssize, size
    local len = 1
    local bodies, body

    while true do
        if len == 0 then
            break
        end
        s = waitChuckSize(fread, s)
        if s then
            size, s = unpack(pystring:split(s, "\r\n", 1))
            len = tonumber(size, 16)
            bodies = waitChuckData(fread, s, len)
            if bodies then
                body = string.sub(bodies, 1, len)
                s = string.sub(bodies, len + 2)
                table.insert(cells, body)
            else
                return -2
            end
        else
            return -1
        end
    end
    tReq.data = pystring:join("", cells)
    return 0
end

local function waitHttpRest(fread, tReq)
    if tReq.header["content-length"] then
        local lenData = #tReq.data
        local lenInfo = tonumber(tReq.header["content-length"])

        local rest = lenInfo - lenData
        if rest > 10 * 1024 * 1024 then  -- limit max data len
            return -1
        end

        if waitDataRest(fread, rest, tReq) < 0 then
            return -2
        end
    else  -- chunk mode
        if #tReq.data > 0 then
            if readChunks(fread, tReq) < 0 then
                return -3
            end
        end
    end
    return 0
end

local function waitHttpHead(fread)
    local stream = ""
    while true do
        local s = fread()
        if s then
            stream = stream .. s
            if string.find(stream, "\r\n\r\n") then
                return stream
            end
        else
            return nil
        end
    end
end

function CasyncHttp:parse(fread, stream)
    local tStatus = pystring:split(stream, "\r\n", 1)
    if #tStatus < 2 then
        print("bad stream format.")
        return nil
    end

    local stat, heads = unpack(tStatus)
    local tStat = pystring:split(stat, " ")
    if #tStat < 3 then
        print("bad stat: "..stat)
        return nil
    end

    local vers, code, descr = unpack(tStat)
    local tReq = {
        vers = vers,
        code = code,
        descr = descr
    }

    local tHead = pystring:split(heads, "\r\n\r\n", 1)
    if #tHead < 2 then
        print("bad head: " .. heads)
        return nil
    end
    local headers, data = unpack(tHead)
    local tHeader = pystring:split(headers, "\r\n")
    local header = {}
    for _, s in ipairs(tHeader) do
        local tKv = pystring:split(s, ":", 1)
        if #tKv < 2 then
            print("bad head kv value: " .. s)
            return nil
        end
        local k, v = unpack(tKv)
        k = string.lower(k)
        header[k] = pystring:lstrip(v)
    end
    tReq.header = header
    tReq.data = data
    if waitHttpRest(fread, tReq) < 0 then
        return nil
    end
    return tReq
end

function CasyncHttp:result(fread)
    local stream = waitHttpHead(fread)
    if stream == nil then   -- read return stream or error code or nil
        return nil
    end
    return self:parse(fread, stream)
end

function CasyncHttp:checkConnect(fd, connecting, toWake)
    local res, msg
    if connecting > 0 then
        local e = coroutine.yield()
        if e.ev_out > 0 then
            g_lb:mod_fd(fd, 0)
        else
            res, msg = coroutine.resume(toWake, "connect failed.")
            assert(res, msg)
            return -1
        end
    end
    return 0
end

function CasyncHttp:procStream(fd, stream, toWake)
    local res, msg
    res = g_lb:write(fd, stream)
    if res then
        local fread = g_lb:read(fd)
        local tReq = self:result(fread)
        res, msg = coroutine.resume(toWake, tReq.data)
        assert(res, msg)
    else
        res, msg = coroutine.resume(toWake, "write failed.")
        assert(res, msg)
    end
    g_lb:co_exit(fd)
end

function CasyncHttp:connect(domain, uri, port, headers, body, cb)
    port = port or 80
    local ip = getIp(domain)
    if #ip == 0 then
        return "request domain failed."
    end
    local tConn = {family=psocket.AF_INET, addr=ip, port=port}

    local fd = setupFd()
    if fd > 0 then
        local connect = tryConnect(fd, tConn)
        if connect then
            local res, msg

            local co = g_lb:co_add(fd, cb)
            if connect > 0 then
                g_lb:mod_fd(fd, 1)
            end
            res, msg = coroutine.resume(co, self, fd)
            assert(res, msg)
            res, msg = coroutine.resume(co, coroutine.running(), domain, uri, headers, body, connect)
            assert(res, msg)
            return coroutine.yield()
        else
            return "connect to domain failed."
        end
    end
end

function CasyncHttp:assertConnect(fd, connecting, toWake)
    local res, msg

    if self:checkConnect(fd, connecting, toWake) == -1 then
        g_lb:co_exit(fd)
        res, msg = coroutine.resume(toWake, "domain connect failed.")
        assert(res, msg)
        return -1
    end
    return 0
end

function CasyncHttp:_get(fd)
    local toWake, domain, uri, headers, body, connecting = coroutine.yield()

    if self:assertConnect(fd, connecting, toWake) < 0 then
        return
    end

    local stream = self:pack('GET', domain, uri, headers, body)
    self:procStream(fd, stream, toWake)
end

function CasyncHttp:get(domain, uri, port)
    return self:connect(domain, uri, port, {}, "", self._get)
end

function CasyncHttp:_put(fd)
    local toWake, domain, uri, headers, body, connecting = coroutine.yield()

    if self:assertConnect(fd, connecting, toWake) < 0 then
        return
    end

    local stream = self:pack('PUT', domain, uri, headers, body)
    self:procStream(fd, stream, toWake)
end

function CasyncHttp:put(domain, uri, headers, body, port)
    return self:connect(domain, uri, port, headers, body, self._put)
end

function CasyncHttp:_post(fd)
    local toWake, domain, uri, headers, body, connecting = coroutine.yield()

    if self:assertConnect(fd, connecting, toWake) < 0 then
        return
    end

    local stream = self:pack('POST', domain, uri, headers, body)
    self:procStream(fd, stream, toWake)
end

function CasyncHttp:post(domain, uri, headers, body, port)
    return self:connect(domain, uri, port, headers, body, self._post)
end

return CasyncHttp
